Purpose（目的）
English
The Delivery Saga is the orchestration layer that coordinates multi-step webhook delivery attempts, retry logic, state transitions, and final dead-lettering. It is the only component allowed to transform the delivery state.

中文
Delivery Saga 是負責控制 webhook 多階段投遞、重試邏輯、狀態轉換與最終死信處理的流程編排核心模組，並且是系統中唯一被允許修改投遞狀態的模組。

Saga Table Specification（Saga 主表規格）

2.1 Table: webhook_delivery_sagas

Schema

Column	Type	Description
id	BIGINT PK	Saga ID
event_id	BIGINT	Links to event
subscription_id	BIGINT	Target subscription
status	ENUM	Pending, InProgress, PendingRetry, Completed, DeadLettered
attempt_count	INT	Total delivery attempts applied by saga
next_attempt_at	TIMESTAMPTZ	When retry scheduler may create/trigger next job
final_error_code	VARCHAR(100)	Error code of the last failed attempt (nullable)
created_at	TIMESTAMPTZ	UTC
updated_at	TIMESTAMPTZ	UTC

2.2 Required Indexes

English

INDEX idx_saga_event (event_id, subscription_id)

INDEX idx_saga_status_retry (status, next_attempt_at)

INDEX idx_saga_status (status)

UNIQUE uniq_saga_event_subscription (event_id, subscription_id)

中文

必須索引：

INDEX idx_saga_event (event_id, subscription_id)

INDEX idx_saga_status_retry (status, next_attempt_at)

INDEX idx_saga_status (status)

UNIQUE uniq_saga_event_subscription (event_id, subscription_id)：
保證同一 event_id + subscription_id 只會存在一筆 saga，用於路由與寫入冪等控制。

2.3 Idempotency Constraints（冪等約束）

English

The unique key (event_id, subscription_id) enforces routing idempotency: inserting the same event and subscription pair twice must not create duplicate sagas.

Saga must treat processing of each job result as idempotent: the same job result (same job_id) processed multiple times must not change saga state more than once (subsequent handling must be no-op).

中文

(event_id, subscription_id) 的唯一鍵用於保證路由冪等：同一事件對同一訂閱不會生成多個 saga。

Saga 在處理 job 結果時必須具備冪等性：同一個 job_id 的結果，即使被重複處理，也只能影響狀態一次，其餘必須是無副作用。

Saga Status Model（狀態機模型）

Status set:

Pending

InProgress

PendingRetry

Completed

DeadLettered

State machine:

Pending ── create first job ──▶ InProgress

InProgress ── job success ──▶ Completed

InProgress ── job failed ──▶ PendingRetry

PendingRetry ── retry allowed ──▶ InProgress（via new job）

PendingRetry ── retry limit reached ──▶ DeadLettered

English notes

State transitions must be atomic and driven only by the Saga Orchestrator.

No other component may directly change status.

中文說明

所有狀態轉換必須由 Saga Orchestrator 以原子操作完成。

任何其他模組禁止直接修改 status。

Responsibilities（功能責任範圍）

4.1 Saga MUST perform（必須負責）

English

Maintain attempt_count based on job results.

Decide when to retry.

Transition between all delivery states.

Decide when to dead-letter.

Produce new jobs for workers (including first job and all retry jobs).

中文

Saga 必須負責：

維護 attempt_count（依據 job 結果遞增）。

判斷是否允許重試。

執行所有投遞狀態轉換。

判定是否進入死信（DeadLettered）。

為 worker 建立新 job（包含第一個 job 與所有重試 job）。

4.2 Saga MUST NOT perform（禁止行為）

English

Send HTTP requests (workers do this).

Modify event records.

Modify subscriptions.

Process job leases.

Interpret payload content.

中文

Saga 禁止：

發送 HTTP 請求（這是 worker 的責任）。

修改 event。

修改 subscription。

處理 job 的 lease 邏輯。

解讀 payload 內容（避免流程層被污染）。

State Definitions（狀態定義）

5.1 Pending

English
Saga exists but no active job is currently in-flight. The next step is to create the first job.

中文
Saga 已建立，但尚未有任何 active job 在執行。下一步是建立第一個投遞 job。

5.2 InProgress

English
Saga currently has exactly one active job in-flight for this subscription.

中文
Saga 正在處理一個 active job。

限制：

任一時刻，同一 saga 只能有一個 active job。

active job 定義：status IN ('Pending', 'Leased') 的 job。

5.3 PendingRetry

English
The last job reached a failed terminal state. Saga is waiting for the retry window to elapse.

中文
上一個 job 已失敗，Saga 正在等待重試時間到來。

限制：

在 PendingRetry 狀態下不可建立新 job，直到 next_attempt_at <= now 且重試仍被允許。

5.4 Completed

English
Delivery succeeded and no further action is required.

中文
投遞成功，Saga 終止。

限制：

一旦狀態轉為 Completed，禁止對該 saga 進行任何後續更新（包含 status 與業務欄位）。

updated_at 停留在進入 Completed 時的時間戳。

5.5 DeadLettered

English
All allowed retry attempts have been exhausted and saga is permanently halted.

中文
到達最大重試次數，Saga 永久停止。

限制：

Saga 進入 DeadLettered 後，禁止任何更新（包含 status、attempt_count、final_error_code 等）。

僅允許由 Dead Letter 模組基於此 saga 建立「全新」 saga，不可修改舊記錄。

Retry Logic（重試邏輯）

6.1 Retry Decision Rules（是否允許重試）

English

A saga may retry only if all of the following are true:

attempt_count < max_retry_limit.

Last job terminal status is Failed.

Backoff window has elapsed: next_attempt_at <= now.

中文

Saga 只有在同時滿足以下條件時才能重試：

attempt_count < max_retry_limit。

最後一次 job 的終止狀態為 Failed。

延遲時間已結束（next_attempt_at <= now）。

6.2 Backoff Calculation（退避時間計算）

English

The backoff formula must be deterministic and documented.

Example (exponential):

next_attempt_at = now + base_delay * (2^(attempt_count - 1))

中文

退避演算法必須可重現且寫死在規格中。

例如：指數退避

next_attempt_at = now + base_delay * (2^(attempt_count - 1))

注意：實際公式可調整，但必須在規格中指定，工程師不可自由發揮。

6.3 Maximum Retry Policy（最大重試策略）

English

The maximum retry limit is configured (e.g., configuration file or per-subscription setting), not hard-coded.

Global defaults may be overridden per subscription as needed.

中文

最大重試次數必須由設定檔決定，而非寫死在程式碼中。

可設定全域預設值，也可在 subscription 層級覆寫。

6.4 Attempt Count Semantics（attempt_count 意義）

English

attempt_count is incremented exactly once for each job result that Saga accepts as new and processes.

If the same job result is delivered multiple times (e.g., worker retrying after crash), Saga must detect duplicates (by job_id or equivalent) and ignore them without incrementing attempt_count again.

中文

attempt_count 僅在 Saga 接受並處理「新的 job 結果」時遞增一次。

若同一個 job 結果因故被重送（例如 worker 當機後重傳），Saga 必須以 job_id 或等效方式辨識重複，避免再次遞增 attempt_count。

Job Production Rules（產生 Job 的規則）

7.1 Single Active Job Per Saga（每個 saga 的唯一 active job）

English

At any time, a saga may have at most one active job (status Pending or Leased).

Historical jobs in Completed or Failed states are allowed and must not be reused.

中文

任一時間點，同一 saga 最多只能擁有一個 active job（Pending 或 Leased）。

已完成或失敗的歷史 job 允許存在，但不得被重用。

7.2 When to create a job（何時建立 job）

English

Saga must create a new job only in the following cases:

status = Pending and no active job exists → create first job and move saga to InProgress.

status = PendingRetry, next_attempt_at <= now, attempt_count < max_retry_limit, and no active job exists → create new job and move saga to InProgress.

中文

Saga 只有在以下情況可以建立新 job：

status = Pending 且不存在 active job → 建立第一個 job，並將 saga 轉為 InProgress。

status = PendingRetry，next_attempt_at <= now，attempt_count < max_retry_limit，且不存在 active job → 建立新 job，並將 saga 轉為 InProgress。

7.3 When NOT to create a job（禁止建立 job 的情況）

English

Saga status is Completed or DeadLettered.

Retry window has not yet elapsed (next_attempt_at > now).

attempt_count >= max_retry_limit.

Another active job already exists for this saga.

中文

禁止建立 job 的情況：

Saga 狀態為 Completed 或 DeadLettered。

重試時間尚未到（next_attempt_at > now）。

attempt_count >= max_retry_limit。

該 saga 已存在另一個 active job。

7.4 Requeue Interaction（與 Dead Letter Requeue 的互動）

English

When a saga is requeued from Dead Letter, the Dead Letter module must create a brand-new saga with status = Pending, attempt_count = 0, next_attempt_at = now.

The new saga then follows the normal job production rules above (Saga will create the first job from Pending).

The original dead saga remains DeadLettered and is never updated again.

中文

當死信被請求重新佇列時，Dead Letter 模組只能建立一個「全新的 saga」，其初始狀態為 Pending，attempt_count = 0，next_attempt_at = now。

新 saga 完全遵循本段既有 job 產生規則（由 Saga 自行建立第一個 job）。

舊 saga 仍維持 DeadLettered 狀態且不可再被更新或建立 job。

Error Handling（錯誤處理）

8.1 After job failure（job 失敗之後）

English

When Saga receives a new failed job result for this saga:

Verify the job result has not been applied before (idempotency check).

Increment attempt_count by 1.

Compute next backoff time and update next_attempt_at.

Set status = PendingRetry.

Set final_error_code from job result.

If retry limit is exceeded after increment:

Set status = DeadLettered.

Persist the final final_error_code.

Trigger Dead Letter module to create a dead_letters entry.

中文

當 Saga 收到此 saga 的「新的失敗 job 結果」時：

先確認該 job 結果尚未被處理過（冪等檢查）。

attempt_count 加 1。

計算下一次重試時間並更新 next_attempt_at。

將狀態設為 PendingRetry。

以該 job 的錯誤碼更新 final_error_code。

若在遞增後已超過最大重試次數：

將狀態改為 DeadLettered。

保留 final_error_code。

觸發 Dead Letter 模組建立對應的 dead_letters 記錄。

8.2 After job success（job 成功之後）

English

When Saga receives a new successful job result:

Verify the job result has not been applied before (idempotency check).

Mark saga as Completed.

Clear or leave final_error_code as is (implementation choice, but must be documented).

中文

當 Saga 收到「新的成功 job 結果」時：

先做冪等檢查，確保該結果尚未被處理。

將 saga 狀態設為 Completed。

final_error_code 可選擇保留最後錯誤碼或清空，但必須在實作文件中明文規定。

Permissions（權限）

Saga-Orchestrator role may:

English

SELECT / INSERT / UPDATE sagas (until they reach terminal states).

Create jobs.

Read events & subscriptions.

Forbidden:

DELETE sagas.

Modify events.

Modify subscriptions.

Direct worker HTTP calls.

中文

Saga-Orchestrator 角色允許：

對 saga 做 SELECT / INSERT / UPDATE（直到進入終止狀態）。

建立 job。

讀取 events 與 subscriptions。

禁止：

刪除 saga。

修改 events。

修改 subscriptions。

直接呼叫 worker 的 HTTP。

Non-Functional Requirements（非功能性要求）

10.1 Performance（效能）

English

State transitions must avoid table scans.

All saga queries that select by time must use indexes on (status, next_attempt_at).

中文

任何狀態轉換與查詢不得掃描整張表。

依時間篩選的查詢必須使用 (status, next_attempt_at) 索引。

10.2 Durability（一致性與耐久性）

English

All saga updates must be strongly consistent and atomic per row.

Terminal states (Completed, DeadLettered) must be durable and never updated afterward.

中文

所有 saga 更新必須具備強一致寫入與單筆原子性。

終止狀態（Completed、DeadLettered）一旦寫入後必須具備耐久性，不可再被更新。
