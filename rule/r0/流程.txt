Phase 1 – Design and migrate database schema
階段一 – 設計並遷移資料庫結構

Phase＝階段 / design＝設計 / migrate＝遷移 / database schema＝資料庫結構

Create all tables exactly as specified: events, subscriptions, webhook_delivery_sagas, webhook_delivery_jobs, dead_letters.
建立所有資料表，必須與規格完全一致：events、subscriptions、webhook_delivery_sagas、webhook_delivery_jobs、dead_letters。

create＝建立 / table＝資料表 / exactly＝完全地 / specified＝被規格定義的

Add all required indexes and unique keys, especially:
特別建立所有必要索引與唯一鍵，尤其是：

events: indexes on created_at, event_type
events：在 created_at 與 event_type 上建立索引

webhook_delivery_sagas: unique (event_id, subscription_id), and indexes on (status, next_attempt_at)
webhook_delivery_sagas：唯一鍵 (event_id, subscription_id)，以及 (status, next_attempt_at) 索引

webhook_delivery_jobs: unique (saga_id, attempt_at), and index (status, lease_until)
webhook_delivery_jobs：唯一鍵 (saga_id, attempt_at)，以及 (status, lease_until) 索引

unique key＝唯一鍵 / index＝索引 / status＝狀態

Enforce InnoDB engine and UTC timestamps in schema.
在 schema 中強制使用 InnoDB 引擎與 UTC 時戳。

enforce＝強制 / engine＝引擎 / timestamp＝時間戳

Phase 2 – Implement event ingestion service
階段二 – 實作事件寫入服務

event ingestion＝事件寫入 / service＝服務

Build a .NET service that only does: INSERT into events with immutable JSON payload.
實作一個只負責將事件以不可變 JSON 寫入 events 的 .NET 服務。

immutable＝不可變 / payload＝負載內容

If external event IDs exist, add a unique key to deduplicate on ingestion.
若存在外部事件 ID，新增唯一鍵，確保寫入時不會重複。

external＝外部的 / deduplicate＝去重

Assign DB role event_ingest_writer to this service, and verify it cannot touch sagas/jobs/dead_letters.
將資料庫角色 event_ingest_writer 指派給此服務，並確認其無法操作 saga/job/dead_letters。

role＝角色 / verify＝驗證 / cannot touch＝無權操作

Phase 3 – Implement subscription configuration API
階段三 – 實作訂閱設定 API

subscription＝訂閱 / configuration＝設定

Build admin APIs to create/update subscriptions records: event_type, callback_url, active, verified.
實作管理 API，用來建立與更新 subscriptions 記錄：event_type、callback_url、active、verified。

admin API＝管理介面 API

Enforce HTTPS callback_url and a verification flow before setting verified = 1.
強制 callback_url 使用 HTTPS，並在設為 verified = 1 前完成驗證流程。

enforce＝強制 / verification flow＝驗證流程

Ensure subscription layer is pure configuration and performs no orchestration, no side effects.
確認訂閱層僅為純設定，不執行流程控制，也不產生任何副作用。

pure configuration＝純配置 / side effect＝副作用

Phase 4 – Implement routing worker (Event → Saga)
階段四 – 實作路由 worker（事件 → Saga）

routing worker＝路由工作程序

Implement a background worker that reacts when new events are inserted into events.
實作背景 worker，在新事件寫入 events 時觸發。

background＝背景 / reacts＝響應

For each event, load subscriptions where event_type matches and active = 1 and verified = 1.
對每個事件，查詢 event_type 相同且 active = 1、verified = 1 的訂閱。

matches＝匹配 / load＝載入

For each (event, subscription) pair, insert into webhook_delivery_sagas using INSERT … ON DUPLICATE KEY UPDATE on unique (event_id, subscription_id).
對每筆（事件、訂閱）組合，透過 INSERT … ON DUPLICATE KEY UPDATE 寫入 webhook_delivery_sagas，依 (event_id, subscription_id) 唯一鍵實現冪等。

pair＝配對 / duplicate key＝重複鍵 / idempotent＝冪等的

Do not create jobs, do not change saga status in this worker.
此 worker 不可建立 job，也不可修改 saga 狀態。

do not＝禁止 / change status＝更改狀態

Phase 5 – Implement Saga Orchestrator
階段五 – 實作 Saga 編排器

orchestrator＝編排器 / state machine＝狀態機

Implement a dedicated service that owns all saga state transitions and job creation.
實作專門服務，唯一負責所有 saga 狀態轉換與 job 建立。

dedicated＝專門的 / owns＝專責

From sagas with status = Pending and no active job, create the first job and move saga to InProgress.
對於 status = Pending 且沒有 active job 的 saga，建立第一個 job，並將 saga 轉為 InProgress。

active job＝正在執行的任務

From sagas with status = PendingRetry, next_attempt_at <= now, attempt_count < max_retry_limit, and no active job, create a new job and move saga to InProgress.
對於 status = PendingRetry 且 next_attempt_at <= now、attempt_count < max_retry_limit，且沒有 active job 的 saga，建立新的 job 並轉為 InProgress。

retry limit＝重試上限 / backoff＝退避

Consume terminal job results (Completed / Failed) and update saga:
處理 job 終止結果（Completed / Failed），並更新 saga：

on success: mark saga Completed.
成功時：將 saga 標記為 Completed。

on failure: increment attempt_count, compute next_attempt_at, move to PendingRetry or DeadLettered, and write final_error_code.
失敗時：增加 attempt_count、計算 next_attempt_at，轉為 PendingRetry 或 DeadLettered，並寫入 final_error_code。

Enforce idempotency of job results (same job_id handled only once).
強制 job 結果具冪等性（相同 job_id 只允許被處理一次）。

handled once＝只處理一次

Respect terminal states: never update sagas once they are Completed or DeadLettered.
嚴格遵守終止狀態：當 saga 進入 Completed 或 DeadLettered 後不得再更新。

terminal state＝終止狀態 / never＝絕不

Phase 6 – Implement Job Workers and Lease Reset Cleaner
階段六 – 實作 Job Worker 與租約重置清理器

worker＝工作程序 / lease＝租約 / cleaner＝清理程序

Job worker:
Job worker：

Acquire jobs via SELECT … FOR UPDATE SKIP LOCKED where status = Pending.
以 SELECT … FOR UPDATE SKIP LOCKED 取得 status = Pending 的 job。

Immediately set status = Leased, lease_until = now + lease_duration.
立即將 status 更新為 Leased，並設定 lease_until = now + lease_duration。

Execute HTTP request to callback_url, then mark job Completed or Failed and store response_status or error_code.
執行對 callback_url 的 HTTP 請求，根據結果將 job 標記為 Completed 或 Failed，並寫入 response_status 或 error_code。

Never modify sagas, never create new jobs.
不得修改 saga，也不得建立新的 job。

Lease Reset Cleaner:
租約重置清理器：

Periodically select status = Leased jobs where lease_until < now.
週期性查詢 status = Leased 且 lease_until < now 的 job。

Reset them back to Pending in an idempotent way.
以具冪等性的方式將其重設為 Pending。

Never touch saga state.
不得動到 saga 狀態。

Phase 7 – Implement Dead Letter module and Requeue flow
階段七 – 實作死信模組與重新佇列流程

dead letter＝死信 / requeue＝重新佇列

When a saga transitions to DeadLettered, insert a row into dead_letters with saga ID, event ID, subscription ID, final error, and payload snapshot.
當 saga 轉為 DeadLettered 時，在 dead_letters 中插入記錄，包含 saga ID、event ID、subscription ID、最終錯誤碼與事件 payload 快照。

snapshot＝快照 / final＝最終的

Expose an operator API to requeue: read from dead_letters, create a new saga with same event/subscription, status = Pending, attempt_count = 0, next_attempt_at = now.
提供操作人員 API 用於重新佇列：從 dead_letters 讀取資料，建立新的 saga，沿用相同 event/subscription，並設定 status = Pending、attempt_count = 0、next_attempt_at = now。

operator＝操作人員 / requeue API＝重新佇列介面

Never modify the old DeadLettered saga, never reuse old jobs.
不得修改舊的 DeadLettered saga，也不可重用任何舊 job。

reuse＝重用 / old＝舊的

Phase 8 – Observability, permissions, and safety checks
階段八 – 可觀測性、權限與安全檢查

observability＝可觀測性 / permissions＝權限

Implement logging at each stage with correlation_id, saga_id, job_id, and delivery status.
在每個階段紀錄日誌，包含 correlation_id、saga_id、job_id 與投遞狀態。

logging＝紀錄日誌 / stage＝階段

Configure DB roles so each component only has the minimal allowed operations described in r01–r04.
根據 r01–r04 的描述設定資料庫角色，確保每個元件只擁有其所需的最小操作權限。

minimal＝最小 / allowed operations＝允許操作

Add integration tests to simulate: duplicate events, duplicate routing, worker crash before updating job result, retry until DeadLetter, and requeue.
撰寫整合測試，模擬：重複事件寫入、重複路由、worker 在更新結果前當機、重試直到死信、以及重新佇列。

integration test＝整合測試 / simulate＝模擬